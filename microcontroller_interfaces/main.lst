CCS PCM C Compiler, Version 4.104, 5967               02-may-16 12:03

               Filename: C:\Users\MA_VEINTIMILLA\Desktop\picc\main.lst

               ROM used: 1243 words (15%)
                         Largest free fragment is 2048
               RAM used: 223 (61%) at main() level
                         230 (62%) worst case
               Stack:    4 worst case (1 in main + 3 for interrupts)

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   214
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.4
0018:  GOTO   01B
0019:  BTFSC  0B.1
001A:  GOTO   02C
001B:  MOVF   22,W
001C:  MOVWF  04
001D:  MOVF   23,W
001E:  MOVWF  77
001F:  MOVF   24,W
0020:  MOVWF  78
0021:  MOVF   25,W
0022:  MOVWF  79
0023:  MOVF   26,W
0024:  MOVWF  7A
0025:  MOVF   20,W
0026:  MOVWF  0A
0027:  SWAPF  21,W
0028:  MOVWF  03
0029:  SWAPF  7F,F
002A:  SWAPF  7F,W
002B:  RETFIE
002C:  BCF    0A.3
002D:  BCF    0A.4
002E:  GOTO   0D8
.................... #include <16f877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT, NOWDT 
.................... #use delay (clock=20000000) 
*
002F:  MOVLW  53
0030:  MOVWF  04
0031:  BSF    03.7
0032:  MOVF   00,W
0033:  BTFSC  03.2
0034:  GOTO   042
0035:  MOVLW  06
0036:  MOVWF  78
0037:  CLRF   77
0038:  DECFSZ 77,F
0039:  GOTO   038
003A:  DECFSZ 78,F
003B:  GOTO   037
003C:  MOVLW  7B
003D:  MOVWF  77
003E:  DECFSZ 77,F
003F:  GOTO   03E
0040:  DECFSZ 00,F
0041:  GOTO   035
0042:  RETURN
.................... #use fast_io(B) 
.................... #use fast_io(D) 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0230:  BCF    03.5
0231:  CLRF   28
0232:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8, parity=n) 
....................  
.................... int x=0; 
.................... int r=0,z=0,i,j,k=0,w=32,uj=0; 
.................... int b=0; 
.................... /*char a[16][3]; 
.................... char a1[16][3]; 
.................... char a2[16][3]; 
.................... char a3[16][3];*/ 
.................... int string4[]= {1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0}; 
0233:  MOVLW  01
0234:  MOVWF  33
0235:  MOVWF  34
0236:  CLRF   35
0237:  CLRF   36
0238:  CLRF   37
0239:  CLRF   38
023A:  MOVWF  39
023B:  MOVWF  3A
023C:  MOVWF  3B
023D:  MOVWF  3C
023E:  CLRF   3D
023F:  CLRF   3E
0240:  CLRF   3F
0241:  CLRF   40
0242:  MOVWF  41
0243:  MOVWF  42
0244:  MOVWF  43
0245:  MOVWF  44
0246:  CLRF   45
0247:  CLRF   46
0248:  CLRF   47
0249:  CLRF   48
024A:  MOVWF  49
024B:  MOVWF  4A
024C:  MOVWF  4B
024D:  MOVWF  4C
024E:  CLRF   4D
024F:  CLRF   4E
0250:  CLRF   4F
0251:  CLRF   50
0252:  MOVWF  51
0253:  MOVWF  52
0254:  MOVWF  53
0255:  MOVWF  54
0256:  CLRF   55
0257:  CLRF   56
0258:  CLRF   57
0259:  CLRF   58
025A:  MOVWF  59
025B:  MOVWF  5A
025C:  MOVWF  5B
025D:  MOVWF  5C
025E:  CLRF   5D
025F:  CLRF   5E
0260:  CLRF   5F
0261:  CLRF   60
0262:  MOVWF  61
0263:  MOVWF  62
0264:  MOVWF  63
0265:  MOVWF  64
0266:  CLRF   65
0267:  CLRF   66
0268:  CLRF   67
0269:  CLRF   68
026A:  MOVWF  69
026B:  MOVWF  6A
026C:  MOVWF  6B
026D:  MOVWF  6C
026E:  CLRF   6D
026F:  CLRF   6E
0270:  CLRF   6F
0271:  CLRF   70
0272:  CLRF   71
0273:  CLRF   72
.................... int string[64]; 
.................... int uit=0; 
.................... int pos1[]={0,0,0}; 
0274:  CLRF   74
0275:  CLRF   75
0276:  CLRF   76
.................... //int string3[] = {'a',"b","c"}; 
.................... int string2[] ={1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0}; 
0277:  BSF    03.6
0278:  MOVWF  10
0279:  MOVWF  11
027A:  CLRF   12
027B:  CLRF   13
027C:  CLRF   14
027D:  CLRF   15
027E:  MOVWF  16
027F:  MOVWF  17
0280:  MOVWF  18
0281:  MOVWF  19
0282:  CLRF   1A
0283:  CLRF   1B
0284:  CLRF   1C
0285:  CLRF   1D
0286:  MOVWF  1E
0287:  MOVWF  1F
0288:  MOVWF  20
0289:  MOVWF  21
028A:  CLRF   22
028B:  CLRF   23
028C:  CLRF   24
028D:  CLRF   25
028E:  MOVWF  26
028F:  MOVWF  27
0290:  MOVWF  28
0291:  MOVWF  29
0292:  CLRF   2A
0293:  CLRF   2B
0294:  CLRF   2C
0295:  CLRF   2D
0296:  MOVWF  2E
0297:  MOVWF  2F
0298:  MOVWF  30
0299:  MOVWF  31
029A:  CLRF   32
029B:  CLRF   33
029C:  CLRF   34
029D:  CLRF   35
029E:  MOVWF  36
029F:  MOVWF  37
02A0:  MOVWF  38
02A1:  MOVWF  39
02A2:  CLRF   3A
02A3:  CLRF   3B
02A4:  CLRF   3C
02A5:  CLRF   3D
02A6:  MOVWF  3E
02A7:  MOVWF  3F
02A8:  MOVWF  40
02A9:  MOVWF  41
02AA:  CLRF   42
02AB:  CLRF   43
02AC:  CLRF   44
02AD:  CLRF   45
02AE:  MOVWF  46
02AF:  MOVWF  47
02B0:  MOVWF  48
02B1:  MOVWF  49
02B2:  CLRF   4A
02B3:  CLRF   4B
02B4:  CLRF   4C
02B5:  CLRF   4D
02B6:  CLRF   4E
02B7:  CLRF   4F
.................... #INT_EXT 
.................... RB0(){ 
.................... delay_ms(200); 
*
00D8:  MOVLW  C8
00D9:  BSF    03.6
00DA:  MOVWF  53
00DB:  BCF    03.6
00DC:  CALL   02F
....................  
.................... for( j = 0;j < 64;j++) 
00DD:  CLRF   2E
00DE:  MOVF   2E,W
00DF:  SUBLW  3F
00E0:  BTFSS  03.0
00E1:  GOTO   141
.................... { 
.................... if(string2[j]==1) 
00E2:  MOVLW  10
00E3:  ADDWF  2E,W
00E4:  MOVWF  04
00E5:  BSF    03.7
00E6:  DECFSZ 00,W
00E7:  GOTO   10C
.................... { 
.................... printf("%u;%u\r\n",j+1,j+1); 
00E8:  MOVLW  01
00E9:  ADDWF  2E,W
00EA:  BSF    03.6
00EB:  MOVWF  53
00EC:  MOVLW  01
00ED:  BCF    03.6
00EE:  ADDWF  2E,W
00EF:  BSF    03.6
00F0:  MOVWF  54
00F1:  MOVF   53,W
00F2:  MOVWF  55
00F3:  MOVLW  1B
00F4:  MOVWF  56
00F5:  BCF    03.6
00F6:  CALL   05A
00F7:  MOVLW  3B
00F8:  BTFSS  0C.4
00F9:  GOTO   0F8
00FA:  MOVWF  19
00FB:  BSF    03.6
00FC:  MOVF   54,W
00FD:  MOVWF  55
00FE:  MOVLW  1B
00FF:  MOVWF  56
0100:  BCF    03.6
0101:  CALL   05A
0102:  MOVLW  0D
0103:  BTFSS  0C.4
0104:  GOTO   103
0105:  MOVWF  19
0106:  MOVLW  0A
0107:  BTFSS  0C.4
0108:  GOTO   107
0109:  MOVWF  19
.................... k=k+1; 
010A:  MOVLW  01
010B:  ADDWF  2F,F
.................... } 
....................  
.................... if(string2[j]==0) 
010C:  MOVLW  10
010D:  ADDWF  2E,W
010E:  MOVWF  04
010F:  BSF    03.7
0110:  MOVF   00,F
0111:  BTFSS  03.2
0112:  GOTO   11A
.................... { 
.................... printf("0;0\r\n"); 
0113:  MOVLW  01
0114:  BSF    03.6
0115:  MOVWF  0D
0116:  MOVLW  02
0117:  MOVWF  0F
0118:  BCF    03.6
0119:  CALL   09C
....................  
.................... } 
....................  
.................... //printf("0;0\r\n"); 
.................... //printf("\r\n"); 
....................  
....................  
....................  
.................... if(string4[j] != string2[j]) 
011A:  MOVLW  33
011B:  ADDWF  2E,W
011C:  MOVWF  04
011D:  BCF    03.7
011E:  MOVF   00,W
011F:  BSF    03.6
0120:  MOVWF  53
0121:  MOVLW  10
0122:  BCF    03.6
0123:  ADDWF  2E,W
0124:  MOVWF  04
0125:  BSF    03.7
0126:  MOVF   00,W
0127:  BSF    03.6
0128:  SUBWF  53,W
0129:  BTFSC  03.2
012A:  GOTO   13E
.................... { 
.................... if(string2[j]==1) 
012B:  MOVLW  10
012C:  BCF    03.6
012D:  ADDWF  2E,W
012E:  MOVWF  04
012F:  BSF    03.7
0130:  DECFSZ 00,W
0131:  GOTO   134
.................... { 
.................... pos1[1]= j; 
0132:  MOVF   2E,W
0133:  MOVWF  75
....................  
.................... } 
.................... if(string2[j]==0) 
0134:  MOVLW  10
0135:  ADDWF  2E,W
0136:  MOVWF  04
0137:  BSF    03.7
0138:  MOVF   00,F
0139:  BTFSS  03.2
013A:  GOTO   13D
.................... { 
.................... pos1[0]= j; 
013B:  MOVF   2E,W
013C:  MOVWF  74
013D:  BSF    03.6
.................... } 
....................  
.................... } 
.................... } 
013E:  BCF    03.6
013F:  INCF   2E,F
0140:  GOTO   0DE
.................... printf("88;88\r\n"); 
0141:  MOVLW  04
0142:  BSF    03.6
0143:  MOVWF  0D
0144:  MOVLW  02
0145:  MOVWF  0F
0146:  BCF    03.6
0147:  CALL   09C
....................  
.................... if(k<w) 
0148:  MOVF   30,W
0149:  SUBWF  2F,W
014A:  BTFSC  03.0
014B:  GOTO   150
.................... { 
.................... pos1[1]=x; 
014C:  MOVF   2A,W
014D:  MOVWF  75
.................... w=w-1; 
014E:  MOVLW  01
014F:  SUBWF  30,F
.................... } 
.................... //printf("%u;%u\r\n",k,w); 
....................  
....................  
....................  
.................... if (string4[47]==0 & string4[55]==0 & string2[47]==1  & string2[55]==1) 
0150:  MOVF   62,F
0151:  BTFSC  03.2
0152:  GOTO   155
0153:  MOVLW  00
0154:  GOTO   156
0155:  MOVLW  01
0156:  BSF    03.6
0157:  MOVWF  53
0158:  BCF    03.6
0159:  MOVF   6A,F
015A:  BTFSC  03.2
015B:  GOTO   15E
015C:  MOVLW  00
015D:  GOTO   15F
015E:  MOVLW  01
015F:  BSF    03.6
0160:  ANDWF  53,F
0161:  DECFSZ 3F,W
0162:  GOTO   164
0163:  GOTO   166
0164:  MOVLW  00
0165:  GOTO   167
0166:  MOVLW  01
0167:  ANDWF  53,F
0168:  DECFSZ 47,W
0169:  GOTO   16B
016A:  GOTO   16D
016B:  MOVLW  00
016C:  GOTO   16E
016D:  MOVLW  01
016E:  ANDWF  53,W
016F:  BTFSC  03.2
0170:  GOTO   17F
.................... { 
.................... uit=1; 
0171:  MOVLW  01
0172:  MOVWF  73
.................... printf("65;66\r\n"); 
0173:  MOVLW  08
0174:  MOVWF  0D
0175:  MOVLW  02
0176:  MOVWF  0F
0177:  BCF    03.6
0178:  CALL   09C
.................... delay_ms(200); 
0179:  MOVLW  C8
017A:  BSF    03.6
017B:  MOVWF  53
017C:  BCF    03.6
017D:  CALL   02F
017E:  BSF    03.6
.................... } 
....................  
.................... if (string4[23]==0 & string4[31]==0 & string2[23]==1  & string2[31]==1) 
017F:  BCF    03.6
0180:  MOVF   4A,F
0181:  BTFSC  03.2
0182:  GOTO   185
0183:  MOVLW  00
0184:  GOTO   186
0185:  MOVLW  01
0186:  BSF    03.6
0187:  MOVWF  53
0188:  BCF    03.6
0189:  MOVF   52,F
018A:  BTFSC  03.2
018B:  GOTO   18E
018C:  MOVLW  00
018D:  GOTO   18F
018E:  MOVLW  01
018F:  BSF    03.6
0190:  ANDWF  53,F
0191:  DECFSZ 27,W
0192:  GOTO   194
0193:  GOTO   196
0194:  MOVLW  00
0195:  GOTO   197
0196:  MOVLW  01
0197:  ANDWF  53,F
0198:  DECFSZ 2F,W
0199:  GOTO   19B
019A:  GOTO   19D
019B:  MOVLW  00
019C:  GOTO   19E
019D:  MOVLW  01
019E:  ANDWF  53,W
019F:  BTFSC  03.2
01A0:  GOTO   1AF
.................... { 
.................... uit=1; 
01A1:  MOVLW  01
01A2:  MOVWF  73
.................... printf("67;68\r\n"); 
01A3:  MOVLW  0C
01A4:  MOVWF  0D
01A5:  MOVLW  02
01A6:  MOVWF  0F
01A7:  BCF    03.6
01A8:  CALL   09C
.................... delay_ms(200); 
01A9:  MOVLW  C8
01AA:  BSF    03.6
01AB:  MOVWF  53
01AC:  BCF    03.6
01AD:  CALL   02F
01AE:  BSF    03.6
.................... } 
....................  
.................... if(uit!=1){ 
01AF:  DECFSZ 73,W
01B0:  GOTO   1B2
01B1:  GOTO   1D7
....................  
.................... printf("%u;%u\r\n",pos1[0]+1,pos1[1]+1); 
01B2:  MOVLW  01
01B3:  ADDWF  74,W
01B4:  MOVWF  53
01B5:  MOVLW  01
01B6:  ADDWF  75,W
01B7:  MOVWF  54
01B8:  MOVF   53,W
01B9:  MOVWF  55
01BA:  MOVLW  1B
01BB:  MOVWF  56
01BC:  BCF    03.6
01BD:  CALL   05A
01BE:  MOVLW  3B
01BF:  BTFSS  0C.4
01C0:  GOTO   1BF
01C1:  MOVWF  19
01C2:  BSF    03.6
01C3:  MOVF   54,W
01C4:  MOVWF  55
01C5:  MOVLW  1B
01C6:  MOVWF  56
01C7:  BCF    03.6
01C8:  CALL   05A
01C9:  MOVLW  0D
01CA:  BTFSS  0C.4
01CB:  GOTO   1CA
01CC:  MOVWF  19
01CD:  MOVLW  0A
01CE:  BTFSS  0C.4
01CF:  GOTO   1CE
01D0:  MOVWF  19
.................... delay_ms(200); 
01D1:  MOVLW  C8
01D2:  BSF    03.6
01D3:  MOVWF  53
01D4:  BCF    03.6
01D5:  CALL   02F
01D6:  BSF    03.6
.................... } 
....................  
.................... for( j = 0;j < 64;j++) 
01D7:  BCF    03.6
01D8:  CLRF   2E
01D9:  MOVF   2E,W
01DA:  SUBLW  3F
01DB:  BTFSS  03.0
01DC:  GOTO   1FA
.................... { 
.................... string4[j] = string2[j]; 
01DD:  MOVLW  33
01DE:  ADDWF  2E,W
01DF:  MOVWF  78
01E0:  CLRF   7A
01E1:  BTFSC  03.0
01E2:  INCF   7A,F
01E3:  MOVF   78,W
01E4:  BSF    03.6
01E5:  MOVWF  53
01E6:  MOVF   7A,W
01E7:  MOVWF  54
01E8:  MOVLW  10
01E9:  BCF    03.6
01EA:  ADDWF  2E,W
01EB:  MOVWF  04
01EC:  BSF    03.7
01ED:  MOVF   00,W
01EE:  BSF    03.6
01EF:  MOVWF  55
01F0:  MOVF   53,W
01F1:  MOVWF  04
01F2:  BCF    03.7
01F3:  BTFSC  54.0
01F4:  BSF    03.7
01F5:  MOVF   55,W
01F6:  MOVWF  00
....................  
.................... } 
01F7:  BCF    03.6
01F8:  INCF   2E,F
01F9:  GOTO   1D9
....................  
.................... r=0; 
01FA:  CLRF   2B
.................... uit=0; 
01FB:  CLRF   73
.................... k=0; 
01FC:  CLRF   2F
.................... } 
....................  
01FD:  BCF    0B.1
01FE:  BCF    0A.3
01FF:  BCF    0A.4
0200:  GOTO   01B
.................... void main() 
.................... { 
*
0214:  CLRF   04
0215:  BCF    03.7
0216:  MOVLW  1F
0217:  ANDWF  03,F
0218:  MOVLW  81
0219:  BSF    03.5
021A:  MOVWF  19
021B:  MOVLW  A6
021C:  MOVWF  18
021D:  MOVLW  90
021E:  BCF    03.5
021F:  MOVWF  18
0220:  CLRF   2A
0221:  CLRF   2B
0222:  CLRF   2C
0223:  CLRF   2F
0224:  MOVLW  20
0225:  MOVWF  30
0226:  CLRF   31
0227:  CLRF   32
0228:  CLRF   73
0229:  BSF    03.5
022A:  BSF    1F.0
022B:  BSF    1F.1
022C:  BSF    1F.2
022D:  BCF    1F.3
022E:  MOVLW  07
022F:  MOVWF  1C
....................  
....................  
....................  
....................  enable_interrupts(INT_EXT); 
*
02B8:  BCF    03.6
02B9:  BSF    0B.4
....................  enable_interrupts(global); 
02BA:  MOVLW  C0
02BB:  IORWF  0B,F
....................  
....................  
....................  
.................... port_b_pullups(TRUE); 
02BC:  BSF    03.5
02BD:  BCF    01.7
.................... set_tris_B(0b11100001); 
02BE:  MOVLW  E1
02BF:  MOVWF  06
....................  
....................  
.................... set_tris_D(0b10000001); 
02C0:  MOVLW  81
02C1:  MOVWF  08
....................  
.................... while(1) 
.................... { 
....................  
.................... if(b==0){ 
02C2:  BCF    03.5
02C3:  MOVF   32,F
02C4:  BTFSS  03.2
02C5:  GOTO   2CA
.................... output_low(PIN_B1); 
02C6:  BCF    06.1
.................... output_low(PIN_B2); 
02C7:  BCF    06.2
.................... output_low(PIN_B3); 
02C8:  BCF    06.3
.................... output_low(PIN_B4); 
02C9:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
....................  
.................... if(b==1){ 
02CA:  DECFSZ 32,W
02CB:  GOTO   2D0
.................... output_low(PIN_B1); 
02CC:  BCF    06.1
.................... output_low(PIN_B2); 
02CD:  BCF    06.2
.................... output_low(PIN_B3); 
02CE:  BCF    06.3
.................... output_high(PIN_B4); 
02CF:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==2){ 
02D0:  MOVF   32,W
02D1:  SUBLW  02
02D2:  BTFSS  03.2
02D3:  GOTO   2D8
.................... output_low(PIN_B1); 
02D4:  BCF    06.1
.................... output_low(PIN_B2); 
02D5:  BCF    06.2
.................... output_high(PIN_B3); 
02D6:  BSF    06.3
.................... output_low(PIN_B4); 
02D7:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==3){ 
02D8:  MOVF   32,W
02D9:  SUBLW  03
02DA:  BTFSS  03.2
02DB:  GOTO   2E0
.................... output_low(PIN_B1); 
02DC:  BCF    06.1
.................... output_low(PIN_B2); 
02DD:  BCF    06.2
.................... output_high(PIN_B3); 
02DE:  BSF    06.3
.................... output_high(PIN_B4); 
02DF:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==4){ 
02E0:  MOVF   32,W
02E1:  SUBLW  04
02E2:  BTFSS  03.2
02E3:  GOTO   2E8
.................... output_low(PIN_B1); 
02E4:  BCF    06.1
.................... output_high(PIN_B2); 
02E5:  BSF    06.2
.................... output_low(PIN_B3); 
02E6:  BCF    06.3
.................... output_low(PIN_B4); 
02E7:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==5){ 
02E8:  MOVF   32,W
02E9:  SUBLW  05
02EA:  BTFSS  03.2
02EB:  GOTO   2F0
.................... output_low(PIN_B1); 
02EC:  BCF    06.1
.................... output_high(PIN_B2); 
02ED:  BSF    06.2
.................... output_low(PIN_B3); 
02EE:  BCF    06.3
.................... output_high(PIN_B4); 
02EF:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==6){ 
02F0:  MOVF   32,W
02F1:  SUBLW  06
02F2:  BTFSS  03.2
02F3:  GOTO   2F8
.................... output_low(PIN_B1); 
02F4:  BCF    06.1
.................... output_high(PIN_B2); 
02F5:  BSF    06.2
.................... output_high(PIN_B3); 
02F6:  BSF    06.3
.................... output_low(PIN_B4); 
02F7:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==7){ 
02F8:  MOVF   32,W
02F9:  SUBLW  07
02FA:  BTFSS  03.2
02FB:  GOTO   300
.................... output_low(PIN_B1); 
02FC:  BCF    06.1
.................... output_high(PIN_B2); 
02FD:  BSF    06.2
.................... output_high(PIN_B3); 
02FE:  BSF    06.3
.................... output_high(PIN_B4); 
02FF:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==8){ 
0300:  MOVF   32,W
0301:  SUBLW  08
0302:  BTFSS  03.2
0303:  GOTO   308
.................... output_high(PIN_B1); 
0304:  BSF    06.1
.................... output_low(PIN_B2); 
0305:  BCF    06.2
.................... output_low(PIN_B3); 
0306:  BCF    06.3
.................... output_low(PIN_B4); 
0307:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==9){ 
0308:  MOVF   32,W
0309:  SUBLW  09
030A:  BTFSS  03.2
030B:  GOTO   310
.................... output_high(PIN_B1); 
030C:  BSF    06.1
.................... output_low(PIN_B2); 
030D:  BCF    06.2
.................... output_low(PIN_B3); 
030E:  BCF    06.3
.................... output_high(PIN_B4); 
030F:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==10){ 
0310:  MOVF   32,W
0311:  SUBLW  0A
0312:  BTFSS  03.2
0313:  GOTO   318
.................... output_high(PIN_B1); 
0314:  BSF    06.1
.................... output_low(PIN_B2); 
0315:  BCF    06.2
.................... output_high(PIN_B3); 
0316:  BSF    06.3
.................... output_low(PIN_B4); 
0317:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==11){ 
0318:  MOVF   32,W
0319:  SUBLW  0B
031A:  BTFSS  03.2
031B:  GOTO   320
.................... output_high(PIN_B1); 
031C:  BSF    06.1
.................... output_low(PIN_B2); 
031D:  BCF    06.2
.................... output_high(PIN_B3); 
031E:  BSF    06.3
.................... output_high(PIN_B4); 
031F:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==12){ 
0320:  MOVF   32,W
0321:  SUBLW  0C
0322:  BTFSS  03.2
0323:  GOTO   328
.................... output_high(PIN_B1); 
0324:  BSF    06.1
.................... output_high(PIN_B2); 
0325:  BSF    06.2
.................... output_low(PIN_B3); 
0326:  BCF    06.3
.................... output_low(PIN_B4); 
0327:  BCF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==13){ 
0328:  MOVF   32,W
0329:  SUBLW  0D
032A:  BTFSS  03.2
032B:  GOTO   330
.................... output_high(PIN_B1); 
032C:  BSF    06.1
.................... output_high(PIN_B2); 
032D:  BSF    06.2
.................... output_low(PIN_B3); 
032E:  BCF    06.3
.................... output_high(PIN_B4); 
032F:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
.................... if(b==14){ 
0330:  MOVF   32,W
0331:  SUBLW  0E
0332:  BTFSS  03.2
0333:  GOTO   338
.................... output_high(PIN_B1); 
0334:  BSF    06.1
.................... output_high(PIN_B2); 
0335:  BSF    06.2
.................... output_high(PIN_B3); 
0336:  BSF    06.3
.................... output_low(PIN_B4); 
0337:  BCF    06.4
.................... //delay_ms(2000); 
.................... }; 
.................... if(b==15){ 
0338:  MOVF   32,W
0339:  SUBLW  0F
033A:  BTFSS  03.2
033B:  GOTO   340
.................... output_high(PIN_B1); 
033C:  BSF    06.1
.................... output_high(PIN_B2); 
033D:  BSF    06.2
.................... output_high(PIN_B3); 
033E:  BSF    06.3
.................... output_high(PIN_B4); 
033F:  BSF    06.4
.................... //delay_ms(2000); 
.................... } 
....................  
.................... if(input(PIN_B7)==0) 
0340:  BTFSC  06.7
0341:  GOTO   347
.................... { 
.................... string[b]= 0; 
0342:  MOVLW  A0
0343:  ADDWF  32,W
0344:  MOVWF  04
0345:  BCF    03.7
0346:  CLRF   00
....................  
.................... } 
.................... if(input(PIN_B7)==1) 
0347:  BTFSS  06.7
0348:  GOTO   351
.................... { 
.................... z=z+1; 
0349:  MOVLW  01
034A:  ADDWF  2C,F
.................... string[b]= 1; 
034B:  MOVLW  A0
034C:  ADDWF  32,W
034D:  MOVWF  04
034E:  BCF    03.7
034F:  MOVLW  01
0350:  MOVWF  00
....................  
.................... } 
....................  
.................... if(input(PIN_B6)==0) 
0351:  BTFSC  06.6
0352:  GOTO   359
.................... { 
.................... string[b+16]= 0; 
0353:  MOVLW  10
0354:  ADDWF  32,W
0355:  ADDLW  A0
0356:  MOVWF  04
0357:  BCF    03.7
0358:  CLRF   00
....................  
.................... } 
.................... if(input(PIN_B6)==1) 
0359:  BTFSS  06.6
035A:  GOTO   364
.................... { 
.................... z=z+1; 
035B:  MOVLW  01
035C:  ADDWF  2C,F
.................... string[b+16]= 1; 
035D:  MOVLW  10
035E:  ADDWF  32,W
035F:  ADDLW  A0
0360:  MOVWF  04
0361:  BCF    03.7
0362:  MOVLW  01
0363:  MOVWF  00
....................  
.................... } 
....................  
.................... if(input(PIN_B5)==0) 
0364:  BTFSC  06.5
0365:  GOTO   36C
.................... { 
.................... string[b+32]= 0; 
0366:  MOVLW  20
0367:  ADDWF  32,W
0368:  ADDLW  A0
0369:  MOVWF  04
036A:  BCF    03.7
036B:  CLRF   00
....................  
.................... } 
.................... if(input(PIN_B5)==1) 
036C:  BTFSS  06.5
036D:  GOTO   377
.................... { 
.................... z=z+1; 
036E:  MOVLW  01
036F:  ADDWF  2C,F
.................... string[b+32]= 1; 
0370:  MOVLW  20
0371:  ADDWF  32,W
0372:  ADDLW  A0
0373:  MOVWF  04
0374:  BCF    03.7
0375:  MOVLW  01
0376:  MOVWF  00
....................  
.................... } 
....................  
.................... if(input(PIN_D0)==0) 
0377:  BTFSC  08.0
0378:  GOTO   37F
.................... { 
.................... string[b+48]= 0; 
0379:  MOVLW  30
037A:  ADDWF  32,W
037B:  ADDLW  A0
037C:  MOVWF  04
037D:  BCF    03.7
037E:  CLRF   00
....................  
.................... } 
.................... if(input(PIN_D0)==1) 
037F:  BTFSS  08.0
0380:  GOTO   38A
.................... { 
.................... z=z+1; 
0381:  MOVLW  01
0382:  ADDWF  2C,F
.................... string[b+48]= 1; 
0383:  MOVLW  30
0384:  ADDWF  32,W
0385:  ADDLW  A0
0386:  MOVWF  04
0387:  BCF    03.7
0388:  MOVLW  01
0389:  MOVWF  00
....................  
.................... } 
....................  
.................... if (input(PIN_D7)==1) 
038A:  BTFSS  08.7
038B:  GOTO   3D7
038C:  CLRF   27
038D:  BTFSC  0B.7
038E:  BSF    27.7
038F:  BCF    0B.7
.................... { 
.................... delay_ms(200); 
0390:  MOVLW  C8
0391:  BSF    03.6
0392:  MOVWF  53
0393:  BCF    03.6
0394:  CALL   02F
0395:  BTFSC  27.7
0396:  BSF    0B.7
.................... printf("87;87\r\n"); 
0397:  MOVLW  10
0398:  BSF    03.6
0399:  MOVWF  0D
039A:  MOVLW  02
039B:  MOVWF  0F
039C:  BCF    03.6
039D:  CLRF   27
039E:  BTFSC  0B.7
039F:  BSF    27.7
03A0:  BCF    0B.7
03A1:  CALL   09C
03A2:  BTFSC  27.7
03A3:  BSF    0B.7
.................... uj=1; 
03A4:  MOVLW  01
03A5:  MOVWF  31
.................... for( i = 0;i < 64;i++) 
03A6:  CLRF   2D
03A7:  MOVF   2D,W
03A8:  SUBLW  3F
03A9:  BTFSS  03.0
03AA:  GOTO   3D0
.................... { 
.................... if(string2[i]==1) 
03AB:  MOVLW  10
03AC:  ADDWF  2D,W
03AD:  MOVWF  04
03AE:  BSF    03.7
03AF:  DECFSZ 00,W
03B0:  GOTO   3B3
.................... { 
.................... k=k+1; 
03B1:  MOVLW  01
03B2:  ADDWF  2F,F
.................... } 
.................... string4[i] = string2[i]; 
03B3:  MOVLW  33
03B4:  ADDWF  2D,W
03B5:  MOVWF  78
03B6:  CLRF   7A
03B7:  BTFSC  03.0
03B8:  INCF   7A,F
03B9:  MOVF   78,W
03BA:  BSF    03.6
03BB:  MOVWF  50
03BC:  MOVF   7A,W
03BD:  MOVWF  51
03BE:  MOVLW  10
03BF:  BCF    03.6
03C0:  ADDWF  2D,W
03C1:  MOVWF  04
03C2:  BSF    03.7
03C3:  MOVF   00,W
03C4:  BSF    03.6
03C5:  MOVWF  52
03C6:  MOVF   50,W
03C7:  MOVWF  04
03C8:  BCF    03.7
03C9:  BTFSC  51.0
03CA:  BSF    03.7
03CB:  MOVF   52,W
03CC:  MOVWF  00
....................  
.................... } 
03CD:  BCF    03.6
03CE:  INCF   2D,F
03CF:  GOTO   3A7
.................... if(k<w) 
03D0:  MOVF   30,W
03D1:  SUBWF  2F,W
03D2:  BTFSC  03.0
03D3:  GOTO   3D6
.................... { 
.................... //pos1[1]=x; 
.................... w=w-1; 
03D4:  MOVLW  01
03D5:  SUBWF  30,F
.................... } 
.................... k=0; 
03D6:  CLRF   2F
.................... //printf("hola"); 
.................... } 
....................  
....................  
.................... if(string[b]!=string2[b]  &  string[b]==0  & uj==1) 
03D7:  MOVLW  A0
03D8:  ADDWF  32,W
03D9:  MOVWF  04
03DA:  BCF    03.7
03DB:  MOVF   00,W
03DC:  BSF    03.6
03DD:  MOVWF  50
03DE:  MOVLW  10
03DF:  BCF    03.6
03E0:  ADDWF  32,W
03E1:  MOVWF  04
03E2:  BSF    03.7
03E3:  MOVF   00,W
03E4:  BSF    03.6
03E5:  SUBWF  50,W
03E6:  BTFSS  03.2
03E7:  GOTO   3EA
03E8:  MOVLW  00
03E9:  GOTO   3EB
03EA:  MOVLW  01
03EB:  MOVWF  50
03EC:  MOVLW  A0
03ED:  BCF    03.6
03EE:  ADDWF  32,W
03EF:  MOVWF  04
03F0:  BCF    03.7
03F1:  MOVF   00,F
03F2:  BTFSC  03.2
03F3:  GOTO   3F6
03F4:  MOVLW  00
03F5:  GOTO   3F7
03F6:  MOVLW  01
03F7:  BSF    03.6
03F8:  ANDWF  50,F
03F9:  BCF    03.6
03FA:  DECFSZ 31,W
03FB:  GOTO   3FD
03FC:  GOTO   3FF
03FD:  MOVLW  00
03FE:  GOTO   400
03FF:  MOVLW  01
0400:  BSF    03.6
0401:  ANDWF  50,W
0402:  BTFSC  03.2
0403:  GOTO   409
.................... { 
.................... x=b; 
0404:  BCF    03.6
0405:  MOVF   32,W
0406:  MOVWF  2A
.................... uj=0; 
0407:  CLRF   31
0408:  BSF    03.6
.................... //printf("xxx"); 
....................  
.................... //output_high(PIN_B6); 
.................... } 
.................... if(string[b+16]!=string2[b+16]  &  string[b+16]==0  & uj==1) 
0409:  MOVLW  10
040A:  BCF    03.6
040B:  ADDWF  32,W
040C:  ADDLW  A0
040D:  MOVWF  04
040E:  BCF    03.7
040F:  MOVF   00,W
0410:  BSF    03.6
0411:  MOVWF  50
0412:  MOVLW  10
0413:  BCF    03.6
0414:  ADDWF  32,W
0415:  ADDLW  10
0416:  MOVWF  04
0417:  BSF    03.7
0418:  MOVF   00,W
0419:  BSF    03.6
041A:  SUBWF  50,W
041B:  BTFSS  03.2
041C:  GOTO   41F
041D:  MOVLW  00
041E:  GOTO   420
041F:  MOVLW  01
0420:  MOVWF  50
0421:  MOVLW  10
0422:  BCF    03.6
0423:  ADDWF  32,W
0424:  ADDLW  A0
0425:  MOVWF  04
0426:  BCF    03.7
0427:  MOVF   00,F
0428:  BTFSC  03.2
0429:  GOTO   42C
042A:  MOVLW  00
042B:  GOTO   42D
042C:  MOVLW  01
042D:  BSF    03.6
042E:  ANDWF  50,F
042F:  BCF    03.6
0430:  DECFSZ 31,W
0431:  GOTO   433
0432:  GOTO   435
0433:  MOVLW  00
0434:  GOTO   436
0435:  MOVLW  01
0436:  BSF    03.6
0437:  ANDWF  50,W
0438:  BTFSC  03.2
0439:  GOTO   440
.................... { 
.................... x=b+16; 
043A:  MOVLW  10
043B:  BCF    03.6
043C:  ADDWF  32,W
043D:  MOVWF  2A
.................... uj=0; 
043E:  CLRF   31
043F:  BSF    03.6
.................... //printf("xxx"); 
....................  
.................... //output_high(PIN_B6); 
.................... } 
.................... if(string[b+32]!=string2[b+32]  &  string[b+32]==0  & uj==1) 
0440:  MOVLW  20
0441:  BCF    03.6
0442:  ADDWF  32,W
0443:  ADDLW  A0
0444:  MOVWF  04
0445:  BCF    03.7
0446:  MOVF   00,W
0447:  BSF    03.6
0448:  MOVWF  50
0449:  MOVLW  20
044A:  BCF    03.6
044B:  ADDWF  32,W
044C:  ADDLW  10
044D:  MOVWF  04
044E:  BSF    03.7
044F:  MOVF   00,W
0450:  BSF    03.6
0451:  SUBWF  50,W
0452:  BTFSS  03.2
0453:  GOTO   456
0454:  MOVLW  00
0455:  GOTO   457
0456:  MOVLW  01
0457:  MOVWF  50
0458:  MOVLW  20
0459:  BCF    03.6
045A:  ADDWF  32,W
045B:  ADDLW  A0
045C:  MOVWF  04
045D:  BCF    03.7
045E:  MOVF   00,F
045F:  BTFSC  03.2
0460:  GOTO   463
0461:  MOVLW  00
0462:  GOTO   464
0463:  MOVLW  01
0464:  BSF    03.6
0465:  ANDWF  50,F
0466:  BCF    03.6
0467:  DECFSZ 31,W
0468:  GOTO   46A
0469:  GOTO   46C
046A:  MOVLW  00
046B:  GOTO   46D
046C:  MOVLW  01
046D:  BSF    03.6
046E:  ANDWF  50,W
046F:  BTFSC  03.2
0470:  GOTO   477
.................... { 
.................... x=b+32; 
0471:  MOVLW  20
0472:  BCF    03.6
0473:  ADDWF  32,W
0474:  MOVWF  2A
.................... uj=0; 
0475:  CLRF   31
0476:  BSF    03.6
.................... //printf("xxx"); 
....................  
.................... //output_high(PIN_B6); 
.................... } 
.................... if(string[b+48]!=string2[b+48]  &  string[b+48]==0  & uj==1) 
0477:  MOVLW  30
0478:  BCF    03.6
0479:  ADDWF  32,W
047A:  ADDLW  A0
047B:  MOVWF  04
047C:  BCF    03.7
047D:  MOVF   00,W
047E:  BSF    03.6
047F:  MOVWF  50
0480:  MOVLW  30
0481:  BCF    03.6
0482:  ADDWF  32,W
0483:  ADDLW  10
0484:  MOVWF  04
0485:  BSF    03.7
0486:  MOVF   00,W
0487:  BSF    03.6
0488:  SUBWF  50,W
0489:  BTFSS  03.2
048A:  GOTO   48D
048B:  MOVLW  00
048C:  GOTO   48E
048D:  MOVLW  01
048E:  MOVWF  50
048F:  MOVLW  30
0490:  BCF    03.6
0491:  ADDWF  32,W
0492:  ADDLW  A0
0493:  MOVWF  04
0494:  BCF    03.7
0495:  MOVF   00,F
0496:  BTFSC  03.2
0497:  GOTO   49A
0498:  MOVLW  00
0499:  GOTO   49B
049A:  MOVLW  01
049B:  BSF    03.6
049C:  ANDWF  50,F
049D:  BCF    03.6
049E:  DECFSZ 31,W
049F:  GOTO   4A1
04A0:  GOTO   4A3
04A1:  MOVLW  00
04A2:  GOTO   4A4
04A3:  MOVLW  01
04A4:  BSF    03.6
04A5:  ANDWF  50,W
04A6:  BTFSC  03.2
04A7:  GOTO   4AE
.................... { 
.................... x=b+48; 
04A8:  MOVLW  30
04A9:  BCF    03.6
04AA:  ADDWF  32,W
04AB:  MOVWF  2A
.................... uj=0; 
04AC:  CLRF   31
04AD:  BSF    03.6
.................... //printf("xxx"); 
....................  
.................... //output_high(PIN_B6); 
.................... } 
....................  
....................  
.................... b=b+1; 
04AE:  MOVLW  01
04AF:  BCF    03.6
04B0:  ADDWF  32,F
.................... if(b==16){ 
04B1:  MOVF   32,W
04B2:  SUBLW  10
04B3:  BTFSS  03.2
04B4:  GOTO   4D9
....................  
....................  
.................... for( i = 0;i < 64;i++) 
04B5:  CLRF   2D
04B6:  MOVF   2D,W
04B7:  SUBLW  3F
04B8:  BTFSS  03.0
04B9:  GOTO   4D8
.................... { 
.................... string2[i] = string[i]; 
04BA:  MOVLW  10
04BB:  ADDWF  2D,W
04BC:  MOVWF  78
04BD:  MOVLW  01
04BE:  MOVWF  7A
04BF:  BTFSC  03.0
04C0:  INCF   7A,F
04C1:  MOVF   78,W
04C2:  BSF    03.6
04C3:  MOVWF  50
04C4:  MOVF   7A,W
04C5:  MOVWF  51
04C6:  MOVLW  A0
04C7:  BCF    03.6
04C8:  ADDWF  2D,W
04C9:  MOVWF  04
04CA:  BCF    03.7
04CB:  MOVF   00,W
04CC:  BSF    03.6
04CD:  MOVWF  52
04CE:  MOVF   50,W
04CF:  MOVWF  04
04D0:  BCF    03.7
04D1:  BTFSC  51.0
04D2:  BSF    03.7
04D3:  MOVF   52,W
04D4:  MOVWF  00
....................  
....................  
.................... } 
04D5:  BCF    03.6
04D6:  INCF   2D,F
04D7:  GOTO   4B6
.................... b=0; 
04D8:  CLRF   32
.................... } 
....................  
....................  
....................  
....................  
.................... } 
04D9:  GOTO   2C3
....................  
.................... } 
04DA:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
